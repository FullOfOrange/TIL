# OS

- 운영체제

  운영체제는 하드웨어와 User-level을 연결하는 중간 소프트웨어 계층. 전원이 들어왔을 때 필수적인 부분만 메모리에 올리고 나머지는 켜질때마다 올리는데 항상 올라와있는 프로세스를 커널이라고 한다.

  - 컴터 자원 관리
  - Interface 제공 ...

- 프로세스

  바이너리 파일을 메모리와 파일 등을 할당받아서 실행되는 상태. PCB 프로세스 제어 블록도 함께 생성한다.

- PCB

  운영체제가 시스템 내의 프로세스를 관리하기 위해 프로세스마다 유지하는 정보들을 담은 커널 내의 자료구조임. 커널 주소공간의 데이터 영역에 존재함.

  또한 이것은 스케쥴링이나 현재 명령어 등등을 담고 있다.

- Context switching

  자원은 한정되어있다. 하지만 여러가지 프로세스를 동시에 (동시는 아니지만) 이실행해야 할 필요가 있다. A 와 B가 동기로 돌아가고 있는데, A에 I/O 콜이 발생해서 wait이 되면, queue에 들어가게 되고 비어있는 CPU에 B를 할당해서 돌아간다. 이때 제어권이 넘어가는 과정을 Context라고 함.

- 프로세스 생성

  init은 운영체제가 처음에 만들고 다음 프로세스들은 부모의 프로세스가 복제된다. PID를 제외한 모든 것이 부모 프로세스와 동일하게 복제된다. fork()를 뜬다부모는 자식들이 다 죽어야만 죽을 수 있다. 만약 부모가 먼저 종료된다면 좀비 프로세스가 된다. (고아다 고아)

- IPC

  프로세스는 각각의 메모리 공간을 가지고 있기에 이들간에 통신을 하려면 여러가지 다른 방법이 필요하다. 예를 들면 shared memory, socket, pipeline 등이 있다.

- 스레드

  프로세스 내에서 일어나는 작업의 흐름을 의미한다. 스레드는 프로세스 내의 모든 공간을 공유하며 각각의 콜스택을 가진다. 콜스텍은 1MB에서 8MB 정도를 가진다고 한다.

  사용자 / 커널 수준 스레드가 있다.

- 스케줄러

  프로세스가 실행될 때 필요한 시스템 자원을 할당해주는 작업이다. 스케쥴링은 Queue로써 이뤄지며 3 종류가 있다. Job Queue (현재 모든 프로세스), Ready Queue(ready 상태의 모든 프로세스), Divice Queue(Device IO를 대기중인 프로세스) 들이 있으며, 큐는 각 프로세스의 PCB 들을 링크드리스트 형태로 줄세우고 포인터를 활용해서 순서를 정한다.

  기법은 프로세스 작업이 끝날때 까지 해당 자원을 사용하는 비선점 기법과 우선순위에 따라 CPU를 강제로 빼앗아 쓰는 선점 기법이 있다.

- 인터럽트

  주변 장치와 입출력 장치는 인터럽트라는 메커니즘으로 관리된다.

  마치 Go에서 IO 작업이 발생한 고루틴을 특정 쓰레드에 넘기는것 마냥 CPU가 마이크로 프로세서에게 이 사항을 알리고, 대신 처리하게 하는 것이다.

  진행 과정은 다음과 같다.

  1. A가 SystemCall로 인터럽트를 발생시킨다.
  2. CPU는 현재 진행중인 기계어 코드를 완료한다.
  3. 현재까지 수행중이던 상태를 PCB에 저장한다. (메모리 주소나 레지스터 값, 상태같은것들)
  4. PC(Program counter)다음에 실행할 명령의 주소를 저장해놓는다
  5. 인터럽트 벡터(인터럽트 헨들러의 주소를 인터럽트 별로 저장하는 곳, 인터페이스 같은 느낌인듯)를 읽고, ISR(Interrupt Service Routine)의 주소를 얻고 그곳으로 점프한 뒤에 루틴을 실행한다.
  6. 해당 코드를 실행한다
  7. 해당 일을 다 끝내면 다시 PCB에서 레지스터를 복원한다.
  8. ISR이 종료될 때 (kill 9 싸인 마냥) IRET 명령어에 의해 인터럽트가 해제된다.
  9. IRET 가 실행되면 PC에 저장한 값을 복원하여 이전 실행하던 상태로 복귀한다.

  CPU의 명령에는 특권 명령과 일반 명령이 있다. 일반 명령은 메모리에서 자료를 읽거나 계산을 하는 등의 모든 프로그램이 수행 가능한 명령이고, 특권 명령은 입출력, 타이머 장치를 접근할 때 사용하는, 보안이 필요한 OS만 접근 가능한 명령이다.

  사용자 명령으로는 입출력 장치에 접근할 수 없다. 따라서 시스템 콜을 이용해서 대신 IO 작업을 해달라고 하는 것이다. 운영체제는 이런 프로그램이 인터럽트를 발생시킨것을 인지하고, 자신이 대신 해준다. (CPU 제어권을 OS에게 넘긴다.)

  ![image.png](https://camo.githubusercontent.com/434061da365494bed98e882a25a9cc36c12ec4d5/68747470733a2f2f696d616765732e76656c6f672e696f2f706f73742d696d616765732f6164616d322f37376531376532302d326663392d313165612d613135662d3831383038356162613163642f696d6167652e706e67)

  

- 주소 바인딩

  프로세스는 실행을 위해 메모리에 적재되면 프로세스만의 독자적 주소공간이 생기는데 이것을 논리적 주소 공간이라고한다.
